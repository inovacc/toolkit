// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Stringer is a tool to automate the creation of methods that satisfy the fmt.Stringer
// interface. For more info see: https://pkg.go.dev/golang.org/x/tools/cmd/stringer
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/constant"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

type Stringer struct {
	Types       []string
	Output      string
	TrimPrefix  string
	LineComment bool
	BuildTags   []string
	Args        []string
}

func NewStringer() *Stringer {
	return &Stringer{}
}

func (s *Stringer) Run() error {
	tags := s.BuildTags
	dir := "."
	if len(s.Args) == 0 {
		s.Args = []string{"."}
	} else if len(s.Args) == 1 && isDirectory(s.Args[0]) {
		dir = s.Args[0]
	} else {
		if len(tags) > 0 {
			return logError("-tags option applies only to directories, not when files are specified")
		}
		dir = filepath.Dir(s.Args[0])
	}

	pkgs := loadPackages(s.Args, tags, s.TrimPrefix, s.LineComment, nil)
	SortPackages(pkgs)

	for _, pkg := range pkgs {
		g := Generator{pkg: pkg}
		g.Printf("// Code generated by \"stringer\"; DO NOT EDIT.\n")
		g.Printf("\n")
		g.Printf("package %s\n", g.pkg.name)
		g.Printf("\n")
		g.Printf("import \"strconv\"\n")

		var found, remaining []string
		for _, t := range s.Types {
			vals := findValues(t, pkg)
			if len(vals) > 0 {
				g.generate(t, vals)
				found = append(found, t)
			} else {
				remaining = append(remaining, t)
			}
		}
		if len(found) == 0 {
			continue
		}
		if len(remaining) > 0 && s.Output != "" {
			return logError("cannot write to single file (-output=%q) when matching types are found in multiple packages", s.Output)
		}
		s.Types = remaining
		src := g.format()
		out := s.Output
		if out == "" {
			out = filepath.Join(dir, baseName(pkg, found[0]))
		}
		if err := os.WriteFile(out, src, 0644); err != nil {
			return err
		}
	}
	if len(s.Types) > 0 {
		return logError("no values defined for types: %s", strings.Join(s.Types, ","))
	}
	return nil
}

func logError(format string, args ...any) error {
	return fmt.Errorf(format, args...)
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func SortPackages(pkgs []*Package) {
	sort.Slice(pkgs, func(i, j int) bool {
		iTest := strings.HasSuffix(pkgs[i].name, "_test")
		jTest := strings.HasSuffix(pkgs[j].name, "_test")
		if iTest != jTest {
			return !iTest
		}
		return len(pkgs[i].files) < len(pkgs[j].files)
	})
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.

	// These fields are reset for each type being generated.
	typeName string  // Name of the constant type.
	values   []Value // Accumulator for constant values of that type.

	trimPrefix  string
	lineComment bool
}

type Package struct {
	name         string
	defs         map[*ast.Ident]types.Object
	files        []*File
	hasTestFiles bool
}
